\documentclass[a4paper]{article}
 
\usepackage{fullpage}
\usepackage{titlesec}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[autolanguage]{numprint}
\usepackage{hyperref}
\usepackage[a4paper]{geometry}
\usepackage{mathtools}

 
\title{Architecture des ordinateurs\\\large Projet : Jeu du Snake}
\author{BEAUREPERE Mathias, GALL Léon}
\date{}
 
\hypersetup{
  pdftitle={Snake},
  pdfauthor={BEAUREPERE Mathias,GALL Léon},
}
\geometry{
 a4paper,
 left=15mm,
 top=10mm,
 right=15mm,
 bottom=20mm,
 }

\makeatletter

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                                                         %
%                                 DOCUMENT                                %
%                                                                         %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\begin{document}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                 HEADER                                  %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\hspace{-0.5cm}\begin{minipage}{0.5\textwidth}
Université de Strasbourg\\
UFR de mathématique et d'informatique
\end{minipage}
\hspace*{\fill}\begin{minipage}{0.5\textwidth}
\hspace*{\fill}L2, Semestre 3, Automne 2021\\
\hspace*{\fill}\@author
\end{minipage}
\\
\begin{center}
  \huge \@title
\end{center}
\vspace*{1cm}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                 RAPPORT                                 %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

Le projet d'architecture des ordinateurs était l'implémentation du célèbre jeu snake en assembleur MIPS.
Pendant la conception, nous avons dû faire des choix.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                  CHOIX D'IMPLÉMENTATION                 %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Choix d'implémentations}

% % % % % % % % % % % % % % % % % % % % %
%                  STYLE                %
% % % % % % % % % % % % % % % % % % % % %
\subsection{Style}
Nous avons choisi  de reprendre le style de programmation de la partie du projet fournie en amont par les professeurs.
C'est pourquoi nous avons mis des indentations uniquement pour les boucles, mais nous avons préféré utiliser des virgules
pour séparer les registres dans les instructions, par souci de clarté.

Nous nous sommes conformés aux normes MIPS, en utilisant les registres sauvegardés
dans nos fonctions appelant d'autres fonctions en interne (en les sauvegardant en amont dans le prologue puis en les restaurant dans l'épilogue).
Dans les fonctions n'appelant pas de fonctions ou pour des informations non utilisées après l'appel d'une fonction,
nous avons utilisé les registres temporaires.

% % % % % % % % % % % % % % % % % % % % %
%         STRUCTURES DE DONNÉES         %
% % % % % % % % % % % % % % % % % % % % %
% \subsection{Structures de données}

% % % % % % % % % % % % % % % % % % % % %
%               FONCTIONS               %
% % % % % % % % % % % % % % % % % % % % %
\subsection{Fonctions}

\subsubsection*{Mise à jour de la direction}
La fonction majDirection utilise la direction donnée par getInputVal, puis vérifie que le serpent ne fait pas de demi-tour à l'aide de la formule : 
\[(direction+2)\mod{4} \neq direction\]
Si il ne fait pas demi-tour, la direction du serpent est mise à jour.

\subsubsection*{Évolution du jeu}
La fonction updateGameStatus fait avancer le serpent, en décalant son tableau de positions d'une case et en modifiant la tête.
Ensuite, elle compare la position de la tête du serpent avec celle du bonbon. Dans le cas où elles sont à la même position, 
le serpent grandit d'une case (en décalant les positions d'une case et la dernière case n'est plus lue mais est toujours accessible 
donc il suffit d'augmenter la taille du serpent pour la lire). Un nouvel emplacement aléatoire pour le bonbon est alors trouvé et un obstacle (ou deux suivant le niveau) 
est également ajouté.

\subsubsection*{Conditions de fin du jeu}
La fonction conditionFinJeu vérifie après chaque évolution du jeu que le serpent ne rentre ni dans lui-même, ni dans un obstacle ou encore que le serpent ne sorte pas de 
la grille. Pour ceci, on compare la position de la tête avec la queue du serpent, avec chaque obstacle (depuis le tableau d'obstacles), ainsi qu'avec la position des bords.

\subsubsection*{Affichage de fin du jeu}
La fonction affichageFinJeu affiche graphiquement le score du joueur et le réécrit suivi d'un message de consolation dans la ligne de commande.

% % % % % % % % % % % % % % % % % % % % %
%       FONCTIONNALITES AJOUTEES        %
% % % % % % % % % % % % % % % % % % % % %
\subsection{Fonctionnalités ajoutées}

\subsubsection*{Affichage graphique du score}
Pour structurer nos données, nous avons créé un tableau statique par chiffre, contenant les pixels de celui-ci. Il est agencé de la façon suivante : la première case de ce 
tableau contient sa taille, et le reste contient la position en ordonnée suivie de la position en abscisse de chaque pixel.
Un autre tableau statique contient les labels de chaque chiffre, afin qu'en accédant à la bonne case de ce tableau, on puisse accéder à l'adresse du tableau de pixels du 
chiffre correspondant.

On réinitialise le dernier affichage graphique. Ensuite, nous regardons si le score est un chiffre ou un nombre et s'il s'agit d'un chiffre nous l'affichons au centre, 
et sinon nous récupérons le chiffre des dizaines et des unités pour les afficher l'un à côté de l'autre de façon centrée.
Pour afficher graphiquement un chiffre, on accède à son tableau de pixels et on affiche chaque pixel en rouge.

\subsubsection*{Système de niveau}
Nous avons également mis en place un système de niveau, qui évolue suivant le score. Chaque fois que le score dépasse un multiple de cinq, le niveau augmente. Par exemple, 
le niveau 0 est composé des scores 0 à 4 (inclus).

Pour que la difficulté augmente avec le niveau, nous avons fait en sorte d'ajouter deux obstacles chaque fois qu'un bonbon est mangé, dès le niveau 1. De plus, la vitesse 
du jeu augmente également de la façon suivante : Le temps d'attente entre deux évolutions est de base 500 millisecondes, et à chaque niveau, ce temps d'attente diminue 
suivant la formule :
\[sleep = 500-50\times niveau\]
Si le niveau dépasse 8, ce qui est extrêmement peu probable, ce temps cesse de diminuer et se comporte comme si le niveau était égal à 8.

Dès que le niveau 3 est atteint, le serpent s'affiche en mode arc-en-ciel.

\subsubsection*{Rainbow snake}
Nous avons créé un tableau statique qui est rempli au fur et à mesure de l'agrandissement du serpent par des couleurs aléatoires de code hexadécimal compris entre 
0x222222 et 0xEEEEEE. Lors du tirage de ces couleurs, on vérifie qu'elle n'est pas trop similaire à une autre couleur du serpent.
Lors de l'affichage, les couleurs de chaque partie du serpent sont récupérées dans ce tableau, et la couleur de la tête reste inchangée afin de ne pas perturber le joueur.

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%    RÉPARTITION DU TRAVAIL ET DIFFICULTES RENCONTREES    %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Répartition du travail et difficultés rencontrées}

% % % % % % % % % % % % % % % % % % % % %
%        RÉPARTITION DU TRAVAIL         %
% % % % % % % % % % % % % % % % % % % % %
\subsection{Répartition du travail}
Nous avons choisi de nous répartir les fonctions, afin de pouvoir travailler en parallèle, chacun sur ses fonctions en utilisant GitLab pour se partager nos versions.
Avant chaque fonction, nous nous sommes mis d'accord sur ce qu'il fallait faire et comment nous allions le faire. Donc la conception des fonctions s'est faite à deux, mais
leur implantation s'est faite chacun de son côté. Bien évidemment, nous avons débuggé nos fonctions ensemble lorsque nous avions des problèmes que nous n'arrivions pas 
à résoudre seuls.

Mathias a programmé les fonctions conditionFinDeJeu, affichageFinJeu et de la fonctionnalité arc-en-ciel tandis que Léon a implémenté les fonction majDirection, 
updateGameStatus, d’affichage graphique et du niveau.

% % % % % % % % % % % % % % % % % % % % %
%        DIFFICULTÉS RENCONTRÉES        %
% % % % % % % % % % % % % % % % % % % % %
\subsection{Difficultés rencontrées}
Nous n'avons pas rencontré de difficultés particulières lors de la réalisation de ce projet. Programmer en assembleur demande de la rigueur, 
et nous avons apprécié le défi imposé.
Pour palier à la difficulté de relecture du code assembleur, nous avons commenté les instructions, ce qui nous a permi de comprendre le code de l'autre, 
et notre code à nous aussi parfois\dots

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                       OBSERVATIONS                      %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\section{Observations}
Nous avons observé que l'axe des abscisses et celui des ordonnées étaient inversées. Il nous a donc fallu adapter nos fonctions et structures de données en conséquence.
Mais cela n'a en aucun cas perturbé notre réalisation.

Nous avons apprécié ce projet qui fût très enrichissant. Il nous a entre autres permis d'élargir notre connaissance du langage MIPS.

\end{document}


